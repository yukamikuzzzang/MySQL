IN 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자.
IN 연산자는 범위 연산이 아니다. 여러 번의 동등 비교로 실행.


1. 상수를 사용한 경우
IN (?, ?, ?)

2. 서브쿼리가 사용된 경우
IN (SELECT .. FROM .. )

IN 연산자에 상수가 사용된 경우 동등 비교와 동일하여 매우 빠르게 처리.
MySQL 8.0 이전 버전까진 IN 절에 튜플(레코드)을 사용하면 항상 풀 테이블 스캔을 했다.

ex)
mysql>  SELECT *
        FROM dept_emp
        WHERE (dept_no, emp_no) IN (('d001', 10017), ('d002', 10144), ('d003', 10054));

IN 절의 상숫값이 단순 스칼라(Scala,단일) 값이 아닌 튜플이 사용.
위와 같이 쿼리를 작성할 경우 성능에 문제가 생겨 일부러 쪼개서 쿼리 작성.
(8.0부터는 튜플을 그대로 나열해도 인덱스를 최적으로 사용할 수 있게 개선됨.)

key_len <.. dept_emp 칼럼(4글자 * 4바이트) + emp_no(4바이트)를 모두 이용해 인덱스 레인지 스캔을 실행.

IN (subquery) 형태의 조건이 사용된 쿼리. 최적화가 매우 까다로웠지만 8.0버전 부터 세미 조인의 최적화가 많이 안정됨.
이전 버전까지는 최적화가 상당히 불안함.
<a>세미조인 최적화(9.3절 고급 최적화 참조)</a>

NOT IN의 실행계획 인덱스 풀 스캔으로 표시. 동등이 아닌 부정형 비교여서 인덱스 처리조건을 줄이는 데에는 사용할 수 없음.
NOT IN 연산자가 프라이머리 키와 비교될 때 가끔 쿼리 실행계획에 인덱스 레인지 스캔이라 표시되는 경우도 있다.
하지만 이는 InnoDB 테이블에서 프라이머리키가 클러스터링 키이기 때문, IN과 같이 효율적으로 실행되진 않는다.

